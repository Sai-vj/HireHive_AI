{# templates/interviews/candidate_interview.html #}
{% extends "base.html" %}

{% block title %}Interview - HireHive{% endblock %}

{% block extra_head %}
<style>
  #timer { font-size: 1.05rem; font-weight: 600; color: #b22222; }
  .question-card { margin-bottom: 12px; padding: 12px; border: 1px solid #e3e6ea; border-radius: 8px; background: #fff; }
  .choice-label { display:block; margin:6px 0; }
  .small-muted { color:#6b7280; }
</style>
{% endblock %}

{% block content %}
<div class="container py-4">
  <div id="interview-root" data-interview-id="{{ interview_id }}"></div>

  <div class="card mb-3">
    <div class="card-body">
      <h4 id="iv-title" class="card-title mb-2">Interview</h4>
      <div id="iv-info" class="mb-2">
        <div><strong>Candidate:</strong> <span id="iv-candidate">—</span></div>
        <div><strong>Scheduled:</strong> <span id="iv-scheduled">—</span></div>
        <div><strong>Duration:</strong> <span id="iv-duration">—</span> mins</div>
        <div id="timer" class="mt-2"></div>
      </div>

      <div id="iv-desc" class="mb-3 small text-muted"></div>

      <div id="controls" class="mb-3">
        <button id="startAttemptBtn" class="btn btn-primary">Start Attempt</button>
        <a id="backToDash" class="btn btn-outline-secondary" href="{% url 'candidate_dashboard' %}">Back</a>
      </div>

      <form id="questionsForm" class="mt-3" style="display:none;">
        <div id="questionsContainer"></div>
        <div class="mt-3">
          <button type="submit" id="submitBtn" class="btn btn-success">Submit Answers</button>
        </div>
      </form>

      <div id="message" class="mt-3"></div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}

<script>
(function(){
  // ---------- small helpers ----------
  function el(id) { try { return document.getElementById(id); } catch(e){ return null; } }
  function escapeHtml(s = '') {
    if (s === null || s === undefined) return '';
    return String(s).replace(/[&<>"'`]/g, (m) =>
      ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '`': '&#x60;' }[m])
    );
  }
  function getCookie(name) {
    try {
      const v = document.cookie.split('; ').find(c => c.startsWith(name + '='));
      return v ? decodeURIComponent(v.split('=')[1]) : null;
    } catch(e){ return null; }
  }
  function setMessage(html, type = 'info') {
    const m = el('message');
    if (!m) return;
    m.innerHTML = `<div class="alert ${type === 'error' ? 'alert-danger' : type === 'warn' ? 'alert-warning' : 'alert-info'}" role="alert">${html}</div>`;
  }

  // ---------- Config ----------
  const root = document.getElementById('interview-root');
  const interviewId = root?.dataset?.interviewId ? Number(root.dataset.interviewId) : null;
  const basePrefix = '/api/interviews'; // change if your API mounts differently
  const AUTOSAVE_PERIOD_MS = 10000;

  // state
  let attemptId = null;
  let timerInterval = null;
  let autosaveIntervalId = null;
  let scheduledStart = null, scheduledEnd = null, interviewDuration = null;
  let _submitInProgress = false;
  let _submitAutoTriggered = false;
  let _visibilityHiddenCount = 0;
  let _bc = null;

  // ---------- utils ----------
  function buildAuthHeaders(json=true) {
    const headers = {};
    const accessToken = localStorage.getItem('access_token');
    if (json) headers['Content-Type'] = 'application/json';
    if (accessToken) {
      headers['Authorization'] = 'Bearer ' + accessToken;
    } else {
      // fallback for session-auth: use CSRF token
      const csrft = getCookie('csrftoken') || '';
      if (csrft) headers['X-CSRFToken'] = csrft;
    }
    return headers;
  }

  // ---------- schedule UI ----------
  function parseISO(s){ try { return s ? new Date(s) : null; } catch(e){ return null; } }
  function updateScheduleUI(data){
    const sched = data.scheduled_at || data.start_time || data.starts_at || data.scheduled_start;
    const end = data.end_time || data.scheduled_end || data.ends_at;
    scheduledStart = parseISO(sched);
    scheduledEnd = parseISO(end);
    interviewDuration = data.duration_minutes || data.duration || null;

    if (data.candidate_name || data.candidate) el('iv-candidate').textContent = data.candidate_name || data.candidate;
    el('iv-scheduled').textContent = scheduledStart ? scheduledStart.toLocaleString() : '—';
    el('iv-duration').textContent = interviewDuration ?? '—';
    el('iv-desc').textContent = data.description || data.detail || data.notes || '';

    if (!scheduledEnd && scheduledStart && interviewDuration) {
      scheduledEnd = new Date(scheduledStart.getTime() + parseInt(interviewDuration,10) * 60*1000);
    }
    updateStartState();
    if (!window._startStateInterval) window._startStateInterval = setInterval(updateStartState, 1000);
  }
  function updateStartState(){
    const now = new Date();
    const startBtn = el('startAttemptBtn');
    const timerEl = el('timer');
    if (scheduledStart && now < scheduledStart) {
      if (startBtn) startBtn.disabled = true;
      const diff = Math.max(0, Math.floor((scheduledStart - now) / 1000));
      const m = Math.floor(diff/60), s = diff%60;
      if (timerEl) timerEl.textContent = `Starts in ${m}m ${s}s`;
      return;
    }
    if (scheduledEnd && now > scheduledEnd) {
      if (startBtn) startBtn.disabled = true;
      if (timerEl) timerEl.textContent = `This interview window is closed.`;
      return;
    }
    if (startBtn) startBtn.disabled = false;
    if (timerEl && interviewDuration) timerEl.textContent = `Duration: ${interviewDuration} mins`;
  }

  // ---------- load detail ----------
  async function loadInterviewDetail(){
    if (!interviewId) { setMessage('Invalid interview id', 'error'); return; }
    try {
      const accessToken = localStorage.getItem('access_token');
      const headers = accessToken ? { 'Authorization': 'Bearer ' + accessToken } : {};
      const resp = await fetch(`${basePrefix}/candidate/${interviewId}/`, { method: 'GET', headers, credentials: 'include' });
      if (!resp.ok) {
        const err = await resp.json().catch(()=>null);
        setMessage('Failed to load interview detail: ' + (err?.detail || resp.statusText), 'error');
        return;
      }
      const data = await resp.json().catch(()=>({}));
      if (data.title) el('iv-title').textContent = data.title;
      updateScheduleUI(data);
    } catch (e) {
      console.error('loadInterviewDetail', e);
      setMessage('Network error loading interview info.', 'error');
    }
  }

  // ---------- questions rendering ----------
  function loadQuestions(questions){
    const form = el('questionsForm');
    const wrap = el('questionsContainer');
    wrap.innerHTML = '';
    const submitBtn = el('submitBtn');
    if (!questions || !questions.length) {
      wrap.innerHTML = '<div class="text-muted">No questions found. Contact recruiter.</div>';
      form.style.display = 'block';
      if (submitBtn) submitBtn.disabled = true;
      return;
    }
    if (submitBtn) submitBtn.disabled = false;

    questions.forEach((q,i) => {
      const qid = q.id || q.question_id || `ai_${i}`;
      const prompt = q.question_text || q.prompt || q.text || '';
      const kind = q.kind || q.question_type || (q.choices ? 'mcq' : 'text');
      const card = document.createElement('div');
      card.className = 'question-card';
      card.innerHTML = `<div><strong>Q${i+1}:</strong> ${escapeHtml(prompt)}</div>`;

      if (String(kind).toLowerCase().includes('mcq') && q.choices) {
        // two supported shapes: array of options OR object map (A/B/C -> text)
        if (Array.isArray(q.choices)) {
          q.choices.forEach(opt => {
            const lbl = document.createElement('label');
            lbl.className = 'choice-label';
            // value uses option text
            lbl.innerHTML = `<input type="radio" name="q_${qid}" value="${escapeHtml(opt)}"> ${escapeHtml(opt)}`;
            card.appendChild(lbl);
          });
        } else {
          try {
            Object.keys(q.choices).forEach(key => {
              const text = q.choices[key];
              const lbl = document.createElement('label');
              lbl.className = 'choice-label';
              lbl.innerHTML = `<input type="radio" name="q_${qid}" value="${escapeHtml(key)}"> <strong>${escapeHtml(key)}.</strong> ${escapeHtml(text)}`;
              card.appendChild(lbl);
            });
          } catch(e){
            // fallback: render as single text input
            const ta = document.createElement('textarea');
            ta.name = `q_${qid}`;
            ta.rows = 3;
            ta.className = 'form-control mt-2';
            card.appendChild(ta);
          }
        }
      } else {
        const ta = document.createElement('textarea');
        ta.name = `q_${qid}`;
        ta.rows = 4;
        ta.className = 'form-control mt-2';
        card.appendChild(ta);
      }
      wrap.appendChild(card);
    });
    form.style.display = 'block';
  }

  function collectAnswers(){
    const answers = {};
    const inputs = document.querySelectorAll('#questionsContainer input[type="radio"], #questionsContainer textarea');
    inputs.forEach(inp => {
      const name = inp.name;
      if (!name) return;
      const qid = name.replace(/^q_/, '');
      if (inp.type === 'radio') {
        if (inp.checked) answers[qid] = inp.value;
      } else if (inp.tagName.toLowerCase() === 'textarea') {
        answers[qid] = inp.value;
      }
    });
    return answers;
  }

  // ---------- autosave ----------
  function startAutoSave(){
    if (!attemptId) return;
    if (autosaveIntervalId) clearInterval(autosaveIntervalId);
    autosaveIntervalId = setInterval(()=> {
      const answers = collectAnswers();
      const accessToken = localStorage.getItem('access_token');
      const headers = { 'Content-Type': 'application/json' };
      if (accessToken) headers['Authorization'] = 'Bearer ' + accessToken; else headers['X-CSRFToken'] = getCookie('csrftoken') || '';
      fetch(`${basePrefix}/candidate/attempts/${attemptId}/autosave/`, {
        method: 'POST', credentials: 'include', headers, body: JSON.stringify({ answers })
      }).catch(err => console.warn('Autosave failed', err));
    }, AUTOSAVE_PERIOD_MS);
  }

  // ---------- timer ----------
  function startTimer(durationMinutes){
    let remaining = parseInt(durationMinutes,10) * 60;
    const timerEl = el('timer');
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(()=> {
      if (remaining <= 0) {
        clearInterval(timerInterval);
        if (timerEl) timerEl.textContent = 'Time up';
        if (!_submitAutoTriggered) { _submitAutoTriggered = true; setMessage('Time up — auto-submitting...', 'warn'); setTimeout(()=> submitAnswers(), 00); }
        return;
      }
      remaining--;
      const m = Math.floor(remaining/60), s = remaining%60;
      if (timerEl) timerEl.textContent = `Time left: ${m}m ${s}s`;
    }, 1000);
  }

  // ---------- tab safety ----------
  const VISIBILITY_THRESHOLD = 2;
  function setupAttemptTabSafety(aid){
    if (!aid) return;
    attemptId = aid;
    try {
      _bc = new BroadcastChannel(`attempt_${attemptId}_channel`);
      _bc.onmessage = (ev) => {
        if (!ev || !ev.data) return;
        if (ev.data.type === 'tab_ping' && ev.data.ts && ev.data.from !== (window.name || '')) {
          setMessage('Warning: Another tab/window open for this attempt. Multiple tabs may auto-submit.', 'warn');
        }
        if (ev.data.type === 'force_submit' && !_submitAutoTriggered) {
          _submitAutoTriggered = true; setMessage('Auto-submit requested by another tab', 'warn'); setTimeout(()=> submitAnswers(), 300);
        }
      };
      _bc.postMessage({ type: 'tab_ping', ts: Date.now(), from: (window.name || '') });
    } catch(e){ console.warn('BroadcastChannel not available', e); }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        _visibilityHiddenCount++;
        if (_visibilityHiddenCount === 1) setMessage('You left the tab — do not open multiple tabs during the interview.', 'warn');
        if (_visibilityHiddenCount >= VISIBILITY_THRESHOLD && !_submitAutoTriggered) {
          _submitAutoTriggered = true;
          setMessage('Multiple tab switches detected — auto-submitting answers.', 'error');
          try { _bc && _bc.postMessage({ type: 'force_submit' }); } catch(e){}
          setTimeout(()=> submitAnswers(), 500);
        }
      } else {
        if (!_submitAutoTriggered) setMessage('Back to interview. Continue answering.', 'info');
      }
    });
  }

  // ---------- submission ----------
  async function submitAnswers(){
    if (_submitInProgress) return;
    _submitInProgress = true;
    try {
      if (!attemptId) { setMessage('No attempt id — cannot submit.', 'error'); _submitInProgress = false; return; }
      const answers = collectAnswers();
      const headers = buildAuthHeaders(true);
      const res = await fetch(`${basePrefix}/candidate/attempts/${attemptId}/submit/`, {
        method: 'POST', credentials: 'include', headers, body: JSON.stringify({ answers })
      });

      let data = null, raw = null;
      try { data = await res.json(); } catch(e) { raw = await res.text().catch(()=>null); }

      if (res.ok) {
        el('questionsForm').style.display = 'none';
        clearInterval(timerInterval); if (autosaveIntervalId) clearInterval(autosaveIntervalId);
        try { window.onbeforeunload = null; } catch(e){}
        const score = data?.score ?? (data && data.result && data.result.score) ?? 'N/A';
        const passed = (data && (data.passed === true || data.passed === 'true')) ? 'Yes' : 'No';
        setMessage(`Submitted! Score: ${score} | Passed: ${passed}`, 'info');
        try { _bc && _bc.postMessage({ type: 'force_submit' }); } catch(e){}
      } else {
        // show meaningful error
        const errDetail = (data && (data.detail || data.error || data.message)) || (raw ? raw : `Status ${res.status}`);
        setMessage('Submit failed: ' + escapeHtml(String(errDetail)), 'error');
      }
    } catch (e) {
      console.error('submit error', e);
      setMessage('Submit failed (network).', 'error');
    } finally {
      _submitInProgress = false;
    }
  }

  // ---------- start attempt ----------
  async function startAttemptHandler(){
    const startBtn = el('startAttemptBtn');
    if (startBtn) startBtn.disabled = true;
    const inviteId = new URLSearchParams(window.location.search).get('invite') || null;
    const now = new Date();
    if (scheduledStart && now < scheduledStart) { setMessage('Cannot start before scheduled time.', 'warn'); if (startBtn) startBtn.disabled = false; return; }
    if (scheduledEnd && now > scheduledEnd) { setMessage('Interview window closed.', 'error'); if (startBtn) startBtn.disabled = true; return; }

    try {
      const headers = buildAuthHeaders(true);
      const resp = await fetch(`${basePrefix}/candidate/${interviewId}/start/`, {
        method: 'POST', headers, credentials: 'include',
        body: JSON.stringify({ invite: inviteId })
      });

      // parse robustly
      let data = null;
      let rawText = null;
      try { data = await resp.json(); } catch(e) { rawText = await resp.text().catch(()=>null); }

      if (!resp.ok) {
        const detail = (data && (data.detail || data.error || data.message)) || (rawText ? rawText : `Status ${resp.status}`);
        const scheduled = (data && (data.scheduled_start || data.scheduledAt || data.scheduledAt)) ? `Starts at: ${new Date(data.scheduled_start || data.scheduledAt).toString()}` : '';
        setMessage(escapeHtml(detail) + (scheduled ? '<br/>' + escapeHtml(scheduled) : ''), 'error');
        if (startBtn) startBtn.disabled = false;
        return;
      }

      // success — try many possible keys
      const attemptIdFromServer = (data && (data.attempt_id || data.id || data.attempt || data.attemptId)) || null;
      const questions = (data && (data.questions || data.qs || data.items)) || [];
      const duration = (data && (data.duration_minutes || data.duration || data.time_minutes)) || interviewDuration || 30;

      if (startBtn) startBtn.style.display = 'none';
      loadQuestions(questions);
      startTimer(duration);

      if (attemptIdFromServer) {
        attemptId = attemptIdFromServer;
        startAutoSave();
        setupAttemptTabSafety(attemptId);
      } else {
        // still allow autosave if backend returns attempt via headers or elsewhere
        setMessage('Warning: attempt id not returned by server; autosave may not work.', 'warn');
      }

      setMessage('Attempt started.', 'info');
      // prevent accidental leave
      window.onbeforeunload = function() {
        return "You have an active interview. Leaving will lose progress.";
      };

      // attach event for submit button (in case not attached)
      el('questionsForm')?.addEventListener('submit', function(e){ e.preventDefault(); submitAnswers(); });

    } catch (err) {
      console.error('Start attempt error:', err);
      setMessage('Failed to start attempt: ' + (err.message || String(err)), 'error');
      if (startBtn) startBtn.disabled = false;
    }
  }

  // ---------- attach handlers & init ----------
  el('startAttemptBtn')?.addEventListener('click', startAttemptHandler);
  el('questionsForm')?.addEventListener('submit', function(e){ e.preventDefault(); submitAnswers(); });

  // init
  loadInterviewDetail();

})();
</script>
{% endblock %}


